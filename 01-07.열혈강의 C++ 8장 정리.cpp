<8장> 상속과 다형성

1.상속의 조건

  상속을 해야하는 적절한 상황 : 상속의 장점과 단점을 이해하고 적절한 경우에만 상속을 하는 판단력 필요
  (디자인 패턴 공부)
  
  1)IS-A 관계 : ~은 ~이다 가 성립 되면 IS-A관계가 성립(ex 학생(자식)은 사람(부모)이다.)
    
  2)HAS-A(HAVE-A) 관계 : 소유 관계 (경찰은 몽둥이를 소유한다)
    
    소유는 항상 상속으로만 표현되지는 않고 포함관계로도 표현할 수 있다.
    
    상속 관계에서는 몽둥이 클래스를 경찰 클래스가 상속해서 몽둥이를 휘두른다.
    
    포함관계에서는 몽둥이 클래스의 객체를 경찰 클래스 내에서 생성해서 몽둥이를 휘두른다.
     - 포함관계에서 주의 점은 부모 클래스 객체에 void생성자가 존재해야한다.
       왜냐하면 객체 멤버가 메모리 공간에 할당하는 과정에서 void생성자를 호출하기 때문이다.
    
    보통은 포함관계를 통해 소유 관계를 표현한다. 상속을 통해 표현하면 두 클래스 사이에 결합도가 높아지기 때문
    
2.상속된 객체와 포인터의 관계 (IS-A관계가 대부분 / HAS-A는 포함관계로 표현을 보통 많이 쓰기 때문)
   
  1)객체 포인터: 객체의 주소 값을 저장할 수 있는 포인터
                -AAA 클래스의 포인터 (AAA*) =
                 AAA 객체의 주소값 + AAA 클래스를 상속하는 Derived 클래스 객체의 주소값 저장 가능
                 
    ex)Person 상속됨 -> Student 상속됨 -> PartTimeStudent 라면
       Person* p1 = new PartTimeStuent 가능 PartTimeStudent는 Person을 상속하고 있기 때문에 포인터로 가리킬수있다.
    
  2)객체포인터의 권한
    AAA객체를 가리키는 객체포인터(AAA*)는 AAA객체 안에 있는 멤버변수와 멤버 함수만 접근할 수 있다.
    =객체 포인터로는 AAA를 상속한 BBB나 CCC에 있는 멤버함수 멤버 변수에는 접근할 수 없다.
     (만약 동적할당을 했더라도 똑같다.)
    
3.상속된 객체와 참조와의 관계

  1)AAA클래스의 레퍼런스(AAA&)은 AAA객체 뿐만 아니라 AAA클래스를 상속하는 Derived 클래스의 객체도 참조 가능하다
  
  2)객체 레퍼런스의 권한
    
    포인터를 레퍼런스로 바꾸면 똑같다.
    "AAA객체를 가리키는 객체레퍼런스(AAA&)는 AAA객체 안에 있는 멤버변수와 멤버 함수만 접근할 수 있다.
    =객체 레퍼런스는 AAA를 상속한 BBB나 CCC에 있는 멤버함수 멤버 변수에는 접근할 수 없다.
     (만약 동적할당을 했더라도 똑같다.)
    
4.Static Binding & Dynamic Binding

  1)오버라이딩 이해
  
    부모 클래스에서 선언한 함수를 자식 클래스에서 또 선언하면 부모클래스의 함수는 가려지고(hiding) 자식클래스 함수가 호출된다.
    
    부모 클래스에 선언된 함수를 호출하고 싶다면 부모클래스 포인터를 사용하면 된다.
    
  2)멤버 함수를 가상(virtual)로 선언하기
  
     virtual void fct(){ 내용 } 가상함수의 선언할 때는 함수 앞에 virtual을 붙혀준다.
     -실제로 존재하지만 존재하지 않는것처럼 보이게 선언
     
  3)가상 함수의 특성은 상속 된다.
    
    AAA의 함수가 가상인데 BBB에 오버라이딩 됐다면 BBB함수도 가상함수가 된다. 이때 BBB를 상속한 CCC에 같은 함수가 있다면
    CCC또한 가상함수가 되지만 함수를 호출한다면 CCC의 함수가 호출된다 AAA와BBB는 가상함수화
    
    이때 혼란을 줄이기 위해 BBB와 CCC함수에 virtual을 명시적으로 선언해준다.
   
  4)static binding과 dynamic binging의 구분
  
    static binding은 함수 호출 시 확실하게 정해진 함수를 호출한다. = 컴파일 하는 동안 호출될 함수 결정
    
    dynamic binding은 상황에 따라 맞는 함수를 호출한다.(여러 객체에 같은 함수가 2개 이상) = 실행(런타임)하는 동안 호출될 함수 결정
    
    다형성 - 모습은 같은데 형태는 다르다.(동질이상) dynamic binding은 다형성의 한 예.
    
  5)오버라이딩된 함수 호출 방법
  
    범위 지정 연산자 ::를 통해 호출 가능
    
5.virtual 소멸자의 필요성

    Base 클래스의 소멸자를 virtual로 설정해줘야 
    Derived 클래스의 소멸자와 Base클래스의 소멸자가 모두 동작하여 메모리 누수가 생기지 않는다.
      
     1. 부모 클래스의 소멸자 호출 하려하나 vitual이기 때문에 자식클래스의 소멸자 먼저 호출
     2. 자식클래스는 부모클래스를 상속하기 때문에 다시 부모클래스의 소멸자 호출. 
    
    
  
