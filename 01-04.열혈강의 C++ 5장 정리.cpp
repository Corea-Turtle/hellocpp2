<5장> 복사생성자

1.C++ &C 스타일 초기화

   c 스타일 int a = 10;
   c++ 스타일 int a(10);

   -객체 또한 c++스타일과 c스타일로 초기화 가능하다.

2.복사 생성자의 형태

  - 자기 자신과 같은 형태(같은 자료형)의 객체를 인자로 받을 수 있는 생성자를 복사 생성자라고 한다.
  
  - 복사 생성자 전달 인자 선언에서 const 선언은 안해줘도 되지만 &선언은 반드시 해줘야한다.
    &선언이 없으면 무한루프에 빠져버리기 때문이다.
    const 선언을 하는 이유는 전달되는 인자가 참조자이기 때문에 내용 변경이 가능하므로 변경하지 못하게 하는 것
    
3.default 복사 생성자

  - 자동으로 삽입되는 복사 생성자를 default 복사 생성자라고 한다.
     
  - 디폴트 복사 생성자는 멤버 변수 대 멤버 변수의 복사를 수행한다.
     
4.복사 생성자의 Deep copy 수행

  1) 얕은 복사(Shallow copy)의 문제점 - 객체 1을 생성하고 객체 2를 생성할 경우 주소값을 매개변수로 쓴다면(포인터) 얕은 복사가 이뤄진다.
                     이떄 객체 2는 복사생성자를 통해 객체 1을 복사한다면 멤버면수의 주소값만을 참조하게 된다.
                     이 상황에서 delete를 통해 메모리를 해제 할 경우 객체 2의 메모리부터 해제 하는데
                     객체 1과 객체 2는 같은 메모리를 가리키는 주소값을 공유하고 있으므로 객체 2가 메모리를 해제 한 후
                     객체 1이 메모리를 해제 할 때는 이미 주소값이 사라져 있어 오류가 뜨게 되는 것이다.
 
  2) 깊은 복사(Deep copy) - 복사 생성자를 따로 지정해주지 않으면 얕은 복사와 같은 오류가 일어날 수 있으므로
                           복사 생성자를 따로 지정해주어 잘못된 메모리 참조를 막는다.
                           
      -정리 : 생성자 내에 "동적 할당"을 하면 반드시 제공해야하는 것 : 1. 소멸자 2.복사생성자
      
5.복사 생성자의 호출 시점

    -효율적인 프로그램 작성을 위해서는 복사 생성자가 호출되는 시점을 이해해야 한다.
    
    1.기존에 생성된 객체로 새로운 객체를 초기화하는 경우
    2.함수 호출 시 객체를 값에 의해 전달하는 경우
    3.함수 내에서 객체를 값에 의햇 리턴하는 경우
  
  1)기존에 생성된 객체로 새로운 객체를 초기화하는 경우
      앞에서 했던것 
      
      #include<iostream>
      using namespace std;

      class AAA
      {
      public:
        AAA(){
          cout<<"AAA() 호출"<<endl;
        }
        AAA(const AAA&a){
          cout<<"AAA(const AAA& a) 호출"<<endl;
        }
      };

      int main()
      {
        AAA obj1;
        AAA obj2(obj1);   //이 부분이다 
      
        return 0;
      }
      
      
  2)함수 호출 시 객체를 값에 의해 전달하는 경우 (call by value)
    
    메모리 할당 -> 생성자를 통한 값 전달(인자 로)
 
  3)함수 내에서 객체를 값에 의해 리턴하는 경우
  
    리턴되는 값은 받아주는 변수가 없더라도, 함수가 호출한 영역으로 "복사"되어 넘어간다.
    
    2)번과 같은 과정이지만 객체가 복사 되는것만 다르다.
    
  
