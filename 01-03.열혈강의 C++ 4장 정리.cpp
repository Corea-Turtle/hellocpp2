<4장>

1. 좋은 클래스 - 캡슐화, 정보은닉 두 가지 특성을 충족하는 클래스
       1) 정보 은닉 - 객체 외부에서 내부 멤버볌수에 접근하지 못하게 하여 버그나 에러를 최소화 시키는 기술
       2) 정보 은닉의 적용 - 모든 멤버변수를 private로 선언
                          class에 접근제어자를 선언 안하면 default값이 기본적으로 private로 설정된다. (struct라면 default값이 public)
                    클래스 내에 멥버 변수 접근이 가능한 메소드가 있다면 이 함수를 통해 외부에서 private 멤버 변수 간접 접근이 가능하다
                    
2. 캡슐화 - 관련있는 데이터와 함수를 하나의 클래스로 묶는 것.
          캡슐화의 유용성  - 대규모 프로세스에서 어떤 전역변수대신 캡슐화된 클래스를 사용했다면 캡슐 안에 값이 변해도 캡슐 안 값만 수정하면 된다.

3. 생성자와 소멸자 - 생성자는 캡슐화하는데 중요한 역할을 한다.
                    클래스를 생성하면 멤버 변수가 private으로 설정하기 때문에
                    외부에서 객체 생성 동시에 초기화하는 것이 불가능하다. 이 때 생성자를 이용하는 것이다.

  1)결국 "생성자" 는 객체 생성과 동시에 원하는 값을 초기화 하는 용도로 대부분 쓰인다.
  
  2)public 생성자, private 생성자
       - 보통 생성자는 public으로 생성된다. private로 생성하는 경우는 나중에 풀어줌
  
  3)생성자의 특징 - 생성자를 하나도 정의하지 않으면 default생성자가 자동 삽입된다.
                   생성자도 함수이므로 오버로딩이 가능하다
                   생성자도 함수이므로 디폴트 매개변수의 설정이 가능하다.
  
  4)생성자와 동적 할당 - 생성자 내에서 동적 할당을 했을 때 문제 점은 메모리 해제를 수동으로 해줘야 한다는 점이다. 
                        이 때문에 등장한 것이 소멸자라는 개념이다.
  
  5)소멸자의 특징 - 클래스 안에 생성자와 소멸자를 생성해주면 객체 소멸시 소멸자가 자동적으로 호출되어 메모리를 해제 해준다.
                  "생성자 내에서 메모리를 동적할당 해 줄 경우, 이를 해제하기 위해 반드시 소멸자를 정의"
  
  6)디폴트(default) 소멸자 -  c++에서는 사용자가 소멸자를 정의해주지 않아도 디폴트 소멸자가 디폴트 생성자 처럼 자동 생성된다.

4.클래스와 배열
  
  1)클래스의 객체 배열은 - Class이름 배열이름[ ];
                       이렇게 선언한다.  이 경우 (Class이름 객체 1) (Class이름 객체 2) 이런식으로 배열 안에 객체가 들어간다.
  
  2)객체 포인터 배열
                      - 배열 안에 객체를 가리키는 포인터가 생성 되는 배열 = new를 통해 객체 생성자를 호출하면서 객체를 생성한다. 마지막엔 delete를 꼭 해줌
                       배열 안에 할당 되어 있는 각각의 포인터가 객체를 가리켜 동적할당 되는 것과 같은 효과를 가진다.
                         
5.this 포인터
  
  - 자기 참조 포인터이다. 객체의 포인터 주소값을 그대로 반환해준다.
                         
  1) 용도  - 연산자 오버로딩에서 유용
        만약 객체 내의 멤버변수와 생성자 내의 매개 변수의 이름이 같다면 this포인터를 통해 구분지을 수 있다.
  
6. friend 선언

  -friend 선언을 통해 private 선언된 멤버 변수의 접근을 허용할 수 있다. -private이나 public이나 상관없다
  [C++ 클래스 내에 멤버에 대한 접근 제한자를 두지 않으면 기본적으로 private이다.]

  -클래스 사이에도 friend 선언이 가능하다. 단, frinend 선언은 단방향성이다. 양방향설정을 하고 싶다면 두 클래스 모두에 friend설정을 해두어야한다.
                         
  -friend 선언은 오버로딩 전까지는 봉인한다.
