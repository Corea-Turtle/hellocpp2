<13장> 예외 처리(Exception Handling)

  
1.기존의 예외 처리 방식

  1)예외를 처리하지 않는 프로그램의 오류
      
    ex)나눗셈을 하는 프로그램에서 나누는수(제수)가 0인 경우
    
  2)전통적인 스타일의 예외 처리
  
    "예외 처리를 위한 코드 부분과 일반적인 프로그램의 흐름을 위한 코드부분을 명확하게 구분 짓지 못한다."
    -작성과 유지보수 모두 불편한 상황
   
   
2.C++의 예외 처리 메커니즘

  -C++은 구조적으로 예외를 처리할 수 있는 메커니즘을 제공한다. = 예외 처리 코드 부분 독립 가능
   ->코드의 가독성과 유지보수성이 좋아짐
   
   1)기본적인 예외 처리 매커니즘(try, catch, throw)
     1.try - 예외 발생에 대한 검사 범위를 설정할 때 사용(try블록 안에서 검사)
      
      try{
          //예외 발생 예상 지역
      }

     2.catch - 예외를 처리하는 코드 블록을 선언할 때 사용. try 블록 내에서 발생한 예외 상황을 
               처리하는 코드가 존재하는 영역, 형태는 리턴 없는 함수와 유사
               
     catch(처리되어야 할 예외의 종류){
        //예외를 처리하는 코드가 존재할 위치
     }
     
     catch는 항상 try 뒤에 바로 이어서 등장해야한다. 
     
      try{
          //예외 발생 예상 지역
      }
       catch(처리되어야 할 예외의 종류){
        //예외를 처리하는 코드가 존재할 위치
      }

      3.throw - 예외 상황이 발생하였음을 알릴 때 사용
      
        throw ex;   //ex를 가리켜 보통은 그냥 "예외"라고 표현을 한다.
                    //ex는 변수, 상수, 객체 등등 대부분의 데이터가 될 수 있다.
        "throw 문에 의해 던져진 예외는, 예외를 감싸는 try 블록 다음에 등장하는 catch 블록에 의해 처리 된다."
 
        ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
        try{
          //예외 발생 예상 지역
             if(예외 상황 발생)
               throw ex       //1.throw에 의한 예외 발생
        }
        catch(excepton ex){                //2.예외의 전달
        //예외 상황 처리
        }
        ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
        
     2)예외 처리 매커니즘의 적용
     
           try{
          //예외 발생 예상 지역
             if(b==0)
               throw b       //1.throw b에 의한 예외 발생
        }
        catch(int excepton){                //2.예외의 자료형(전달되는 자료형)과 전달받는 자료형은 일치해야한다.
        //예외 상황 처리                     // 함수의 인자 전달과 형태가 비슷하다.
        }
        
     3)예외 처리 적용 시 프로그램의 흐름
     
        예외가 발생하면 try 블록내 throw 뒤의 나머지 문장들은 실행되지 않고 catch로 넘어감
       
       
3. Stack Unwinding(스택 풀기)

    1)전달되는 예외
    
      -처리되지 않은 예외는 호출한 영역으로 다시 전달된다. 그리고 호출한 영역에 catch 문이 있을경우 catch 문으로 전달된다.
          
      -예외가 처리되는 과정은 함수의 스택이 풀리는 순서와 일치한다. 따라서 예외의 전달을 스택 풀기라고 하는 것.
     
    2)처리되지 않은 예외
     
      -처리 되지 않은 예외는 absort함수에 의해 처리된다.(기본 지원 함수: 프로그램 종료)
   
    3)전달되는 예외 명시하기
    
      1.함수를 정의 할 때 전달 되는 예외의 종류를 명시해 줄 수 있다.
        
      int fct(double d) throw (int) //fct 함수는 int 형 예외르 전달 할 수 있다.
      {
      }

`     2.전달되는 예외가의 종류가 둘 이상일 때 

      int fct(double d) throw (int, double, cahr*)
      {
      }

      3.어떠한 예외도 전달하지 않는다.

      int fct(double d) throw()
      {
      }

      만약 예외가 전달되면 absort 함수가 호출되면서 프로그램은 종료
      
      이렇게 정의하는 이유는 유지보수성 때문이다.
      이렇게 정의하면 함수 내부를 보지 않아도 try~ catch문을 적절히 사용할수 있다.
      
    4)하나의 try 블록과 여려개의 catch 블록
    
      하나의 try 블록 내에서, 둘 이상의 서로 다른 예외(자료형이 서로 다른 예외)가 발생할 수 있는 상황도 존재.
      ->이럴 때는 catch 블록 이어서 선언.
        
      try{
          if(num>0)
              throw 10; //int형 예외 전달
          else
              throw 'm' //char형 예외 전달
      }
      catch(int exp){
          cout<<"int형 예외 발생"<<endl;
      }
      catch(char exp){
          cout<<"char형 예외 발생"<<endl;
      }

      이런식으로 선언한다.
        
      -주의 할 점 : try블록~catch 블록 사이에 다른 문장이 존재할 수 없다.
                   이어서 선언되는 catch 블록 사이에도 다른 문장이 존자할 수 없다.
                     
      -하나의 try 블록 내에서 둘 이상의 서로 다른 예외가 발생 할 수 있는 상황
      
        예외상황에 대한 클래스 생성
        if(strcmp(account, acc) || sidl=id) 
            throw AccountExpt(acc, id);     //AccountExpt는 예외상황에 대한 클래스이다.
        
        =예외 상황에 대한 try블록의 범위를 어떻게 지정해 줘야하는가는 프로그램의 업무적 성격에 따라 달라진다.
      
          
4.예외 상황을 나타내는 클래스의 설계

    예외를 정의하는 클래스 = 예외 클래스, 예외를 위해 생성하는 객체 = 예외 객체
  
    -요즘 하드웨어의 성능이 좋아졌기 때문에 유지보수성과 가독성에 중점을 두므로 예외 클래스를 디자인 하는 것이 좋다.
    -try catch 구문의 속도 저하가 부담될 경우, 전통적 방식의 예외 처리를 주로 사용
  
  
5.예외를 나타내는 클래스와 상속
   
  -예외의 형태가 유사한 경우 예외 클래스를 상속시키기도 함.
    
   1)catch 블록의 예외가 전달되는 방식
   
      try블록에서 예외를 캐치 블록으로 전달
      catch 1 , catch 2, catch 3 - 이런식으로 함수오버로딩과 비슷하게 생겨서 바로 찾을 것 같지만
      자료형이 일치하지 않으면 순차적으로 캐치블록의 예외 조건을 비교한다. 
      catch 1, 2, 3 이런식으로
 
   2)상속 관계에 있는 예외 객체의 전달
   
     예외 클래스a를 예외 클래스b가 예외 클래스b를 예외 클래스 c가 상속한다고 할때
     b와 c 조건의 예외를 모두 예외 클래스 a가 처리하게 된다.
     따라서 예외 조건에 따라 적절한 예외 클래스가 호출되도록 상속관계를 잘 생각하고 써야한다.
        
     이렇게 상속 관계일 때는 예외 처리 객체 순서를 c b a 순으로 배치하면 된다.(IS-A 관계는 역으로 성립되지 않으므로)

        
6. new 연산자에 의해 전달되는 예외

   new 연산자에 의해서 메모리 할당이 실패 했을 때, NULL포인터가 리턴되는 것은 과거의 표준
   최근의 표준은 헤더파일 new에 선언되어 있는 bad_alloc 예외가 전달된다.
   vc++ 컴파일러 사용자는 MSDN을 참조하면 자세한 사용법을 알 수 있다.
        
        
7.예외 처리에 대한 나머지 문법 요소
  
    1)모든 예외를 처리하는 catch 블록
   
      다음의 catch블록은 모든 예외를 다 잡아 낼 수(처리할 수) 있다.
      
      try{
        ...
      }
      catch(...){ //"..."은 모든 예외를 다 처리하겠다는 선언
       ... 
      }

    2)예외 다시 던지기
      
      -throw 문장은 예외를 다시 던지기 위한 용도로 사용되기도 함.
      
      다음과 같은 경우에 예외를 다시 던질 것을 고려
      
      1. catch 블록에 의해 예외를 잡고 보니, 처리하기가 마땅치 않다. 다른 catch 블로게 의해서 예외가 처리되길 바란다.
        
      2. 하나의 예외에 대해서 처리되어야 할 영역(예외가 발생했음을 알려 줘야 할 영역)은 둘 이상이다.
        
      =예외를 다시 던져야할 상황은 쉽게 등장하지 않는다.
      
      
    
   
