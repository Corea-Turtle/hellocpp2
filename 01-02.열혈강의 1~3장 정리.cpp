<1장>

1. cpp의 입출력은 std::cin과 std::cout으로 한다. std::endl;은 문장이 끝났음을 선언함과 동시에 줄바꿈을 해준다.
  헤더파일은 미리 컴파일 된 헤더인 "stdafx.h"와 "pch.h" 둘 중 하나를 쓰고
  입출력 관련 헤더 파일은 <iostream>이다. 둘다 선언부에 써주면 된다.
  
cin>>입력 변수1>>입력 변수2 이런식으로 연속되게 입력 요구가 가능하다.
  
2. c++은 함수의 이름이 중복 가능하다.
  C에서는 불가능한 일이었지만 Add라는 이름의 함수가 중복으로 존재 가능하다.
  이를 overloading이라고 한다.
  
  오버로딩의 조건
  
  함수의 이름 = 같다.
  매개 변수 타입, 개수 = 다르다.
  
  주의할 점은 모호성(Ambiguous)에 걸리지 않도록 잘 작성해야한다.
  
3. 디폴트 매개 변수를 쓸 때 주의 할 점
  반드시 가장 오른쪽 매개변수부터 default로 초기화해준다.
  
4. 인라인 함수(in-line)
  선언부에 매크로를 사용하면 함수 호출시 오버헤드되는 것을 막아주고 성능상의 이점을 볼 수 있다.
  하지만 매크로는 매개 변수의 형을 선언하지 못해 오류가 생기기 쉽다.
  
  함수는 매크로와 반대로 호출시 여러과정을 거치면서 오버헤드 되고 성능이 느려진다.
  대신 매개변수의 형을 정확히 표기하기 때문에 오류가 적다.
  
  매크로와 함수의 장점을 합친 것이 인라인 함수이다.
  매크로의 특징인 오버헤드를 막아주고 성능상 이점을 가지면서 매개변수의 형도 확실히 정의해 준다.
  인라인 함수는 유용하지만 길이가 길어지면 오히려 성능이 저하되기도 한다고 한다.
  따라서 인라인 함수를 사용할지 말지는 컴파일러가 알아서 판단해준다.
  
5.namespace(소속)
  객체 지향 언어는 다수의 개발자가 동시에 개발하는데 최적화되어 있는 언어이다.
  하지만 사람의 생각은 다 거기서 거기이기 때문에 개발 할 때 함수의 이름이 겹치는 경우가 발생한다.
  이럴때 namespace를 사용해주면 말끔하게 해결된다.
  
  namespace 사용법 
  
  namespace TEST
{
      Add{ 함수 }
      Block{ 함수 }
}
  이렇게 네임스페이스가 있으면
  
  using TEST::Add; - TEST소속의 Add함수를 사용한다는 뜻
  using namespace::TEST; Add나 Block함수를 사용하면 TEST소속의 함수라는것이라고 명명 따라서 TEST::를 생략할 수 있음
  
  전역 변수 앞에 ::를 붙히면 명시적으로 전역변수라는 것을 선언하는 것이다.
 
    
<2장>

 1. const 상수화를 잘쓰자

 2. bool = true, false, 를 반환하는 자료형  true false를 const로 상수화 시킬 필요없는 편의성 제공

 3. 레퍼런스 - 레퍼런스는 인스턴스의 별칭이다. 
    선언 방식
    int &ref = val; - val이라는 int형 인스턴스에 ref라는 레퍼런스를 붙힘
    정확히는 인스턴스가 사용하는 메모리 공간에 또 다른 이름이 붙는거라 만들어지고 나면 완전히 같은 것이다.
    
    인스턴스는 새로운 메모리 공간에 이름을 부여, 레퍼런스는 이미 이름이 있는 메모리 공간에 이름을 하나 더 부여
    따라서 - 상수는 레퍼런스가 붙을 수 없다. 선언과 동시헤 반드시 초기화해야한다.
      
 4. call by reference - 포인터를 이용, 참조자를 이용한 두가지 방법이 있는데 참조자를 이용하면
                        원래 인스턴스를 직접 인용할 수 있다.
                        단점은 함수가 call by value인지 call by reference인지 알수 가 없는것
 
 5. call by value - 인자의 값을 그대로 전달(크기가 커지면 함수 호출이 부담스러워진다)
                    이를 대신하는 것이 call-by-reference이다.
                    레퍼런스형태로 인자를 받게 되면 값이 복사되지 않고 메모리를 그대로 사용할 수 있다.
                    (성능 향상)
                    레퍼런스를 통해 데이터를 변경하는 경우엔 에러가 날 수 있는데 경고메세지가 뜨지 않는다.
                    따라서 이때 const를 사용하여 상수화 시켜주면 이러한 경우를 막을 수 있다.
      
 6. 레퍼런스를 리턴하는 함수 - 레퍼런스를 리턴하는 함수 안에 지역변수를 선언 및 초기화해서 리턴하면 
                             함수가 끝나면 지역변수는 사라지기 때문에 레퍼런스가 가리키는 메모리 자체가 사라진다.
                             이런 짓은 하지 말자.
                             
 7. new delete 연산자  - malloc free대신 씀 그리고 형변환을 자동으로 알아서 해주기 때문에 편리
 
                        int *val = new int; int형 데이터 1개 저장을 위한 메모리 동적 할당
                        int *arr = new int[size]; 길이가 size인 int형 배열을 위한 메모리 동적 할당
                        
                        반환시 delete val;   val이 가리키는 메모리 반환
                              delete[] arr arr이 가리키는 배열 반환
                         
                        new연산자가 "메모리 할당에 실패"할 시 NULL 포인터를 리턴한다.
                        정수 0이다. 매크로 상수 NULL이나 0직접 사용도 가능.
                          
<3장>

1. 구조체 - 부류를 형성하는 데이터들을 하나의 자료형으로 정의, 관리 프로그램 구현 유지보수 용이
   클래스 - 변수들(구조체?) + 함수 // 자료와 자료를 연결하는 방법들로 구성
           ㄴ=멤버 변수          ㄴ=멤버 함수

2. 데이터 추상화 -> 클래스 -> 객체 // 객체쪽으로 올 수록 실체화가 된다고 보면 됨.
                                 // 추상화는 데이터들과 데이터들의 상관관계(함수)를 수치화 -> 
                                 // 클래스는 데이터들을 부류로 묶고 상관관계도 부류로 묶어서 하나의 클래스로 코드화
                                 // 객체는 클래스를 기반으로 생성하는 생산물 1 2 3 과 같은 것이다.

3. 클래스 내부 접근, 외부 접근 - 같은 클래스 내에서 멤버에 영향을 주면 내부 접근
                               클래스 외부에서 클래스 내의 멤버를 호출하면 외부 접근 
   
   public, protected, private  - public은 접근 허용 범위가 공개
                                 priavatd는 클래스 내부 접근만 허용, 외부에서 접근하면 에러 발생
                                 protected는 나중에 설명
                                 
                    //참고 : 클래스의 멤버 함수를 정의할 떄, void 반환형은 생략하는 것이 일반적이다.
                                 
 4. 멤버 함수가 길이가 길어질 경우 클래스 외부에 정의가 가능하다.
                          
                         형태 ex)
                         
                         class Car{
                           public:
                              void Light();  //Light의 선언
                         }
                          
                         void Car::Light(){  //Light의 정의
                              
                         }

                         이런식으로 선언만 클래스 내부에하고 클래스 외부에 멤버 함수 정의 가능.
    
    클래스 내부에 함수를 정의 한다는 것은 함수를 인라인 처리하라고 강요하는 것이다.
    하지만 외부에 정의 할때도 인라인 처리를 하면 동일한 효과를 낼 수 있다.
  
    //프로젝트를 할 떄 구조 :                      
    클래스 선언은 헤더 파일, 클래스 멤버 함수의 정의는 cpp파일, main.cpp에서는 간단한 실행으로 나누면 
    프로젝트 확장과 유지보수의 용이성을 가질 수 있다.                     
